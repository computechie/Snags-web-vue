{"ast":null,"code":"import { createCommentVNode as _createCommentVNode, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, resolveComponent as _resolveComponent, normalizeClass as _normalizeClass, normalizeStyle as _normalizeStyle, withCtx as _withCtx, createVNode as _createVNode, withModifiers as _withModifiers, createElementVNode as _createElementVNode, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\";\n\nconst _withScopeId = n => (_pushScopeId(\"data-v-29f7b628\"), n = n(), _popScopeId(), n);\n\nconst _hoisted_1 = [\"src\", \"onLoad\"];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_v_zoomer = _resolveComponent(\"v-zoomer\");\n\n  return _openBlock(), _createElementBlock(_Fragment, null, [_createCommentVNode(\" touchmove.prevent is used to stop the page scroll elastic effects \"), _createElementVNode(\"div\", {\n    class: _normalizeClass([{\n      'anim': $data.autoSliding && !$data.isPointerDown\n    }, \"vue-zoomer-gallery\"]),\n    style: _normalizeStyle({\n      'background-color': $props.backgroundColor\n    }),\n    onMousemove: _cache[1] || (_cache[1] = (...args) => $options.onMouseMove && $options.onMouseMove(...args)),\n    onMousedown: _cache[2] || (_cache[2] = (...args) => $options.onMouseDown && $options.onMouseDown(...args)),\n    onMouseout: _cache[3] || (_cache[3] = (...args) => $options.onMouseUp && $options.onMouseUp(...args)),\n    onMouseup: _cache[4] || (_cache[4] = (...args) => $options.onMouseUp && $options.onMouseUp(...args)),\n    onTouchstart: _cache[5] || (_cache[5] = (...args) => $options.onTouchStart && $options.onTouchStart(...args)),\n    onTouchend: _cache[6] || (_cache[6] = (...args) => $options.onTouchEnd && $options.onTouchEnd(...args)),\n    onTouchmove: _cache[7] || (_cache[7] = _withModifiers((...args) => $options.onTouchMove && $options.onTouchMove(...args), [\"prevent\"]))\n  }, [(_openBlock(), _createElementBlock(_Fragment, null, _renderList(3, (n, i) => {\n    return _createVNode(_component_v_zoomer, {\n      ref_for: true,\n      ref: \"zoomers\",\n      key: i + '-' + $data.selIndex,\n      class: _normalizeClass([['left', 'middle', 'right'][i], \"slide\"]),\n      style: _normalizeStyle([$options.leftStyle, $options.middleStyle, $options.rightStyle][i]),\n      \"max-scale\": 10,\n      zoomed: $data.currentZoomed,\n      \"reset-trigger\": i,\n      \"aspect-ratio\": $data.imageAspectRatios[$data.selIndex + i - 1] || 1,\n      pivot: $props.pivot,\n      \"zooming-elastic\": $props.zoomingElastic,\n      \"limit-translation\": $props.limitTranslation,\n      \"double-click-to-zoom\": $props.doubleClickToZoom,\n      \"mouse-wheel-to-zoom\": $props.mouseWheelToZoom,\n      onSwipe: $options.onImageSwipe\n    }, {\n      default: _withCtx(() => [$data.selIndex + i - 1 > -1 && $data.selIndex + i - 1 < $props.list.length ? (_openBlock(), _createElementBlock(\"img\", {\n        key: 0,\n        src: $props.list[$data.selIndex + i - 1],\n        draggable: \"false\",\n        style: {\n          \"object-fit\": \"contain\",\n          \"width\": \"100%\",\n          \"height\": \"100%\"\n        },\n        onLoad: $event => $options.onImageLoad($data.selIndex + i - 1, $event),\n        onDragstart: _cache[0] || (_cache[0] = (...args) => $options.onImageDragStart && $options.onImageDragStart(...args))\n      }, null, 40\n      /* PROPS, HYDRATE_EVENTS */\n      , _hoisted_1)) : _createCommentVNode(\"v-if\", true)]),\n      _: 2\n      /* DYNAMIC */\n\n    }, 1032\n    /* PROPS, DYNAMIC_SLOTS */\n    , [\"class\", \"style\", \"zoomed\", \"reset-trigger\", \"aspect-ratio\", \"pivot\", \"zooming-elastic\", \"limit-translation\", \"double-click-to-zoom\", \"mouse-wheel-to-zoom\", \"onSwipe\"]);\n  }), 64\n  /* STABLE_FRAGMENT */\n  ))], 38\n  /* CLASS, STYLE, HYDRATE_EVENTS */\n  )], 2112\n  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */\n  );\n}","map":{"version":3,"mappings":";;;;;;;;6DACEA,4FACAC,oBA2CM,KA3CN,EA2CM;IA1CHC,KAAK;cAAkBC,qBAAW,CAAKA;IAAlC,GAMA,oBANA,EA0CF;IAvCHC,KAAK;0BAA8BC;IAA9B,EAuCF;IAnCHC,WAAS,yCAAEC,qDAAF,CAmCN;IAlCHC,WAAS,yCAAED,qDAAF,CAkCN;IAjCHE,UAAQ,yCAAEF,iDAAF,CAiCL;IAhCHG,SAAO,yCAAEH,iDAAF,CAgCJ;IA/BHI,YAAU,yCAAEJ,uDAAF,CA+BP;IA9BHK,UAAQ,yCAAEL,mDAAF,CA8BL;IA7BHM,WAAS,wDAAUN,qDAAV,EAAqB,WAArB;EA6BN,CA3CN,kBAgBEO,oBA0BWC,SA1BX,EA0BW,IA1BX,EA0BWC,YAzBQ,CAyBR,EAzBS,CAAVC,CAAU,EAAPC,CAAO,KAAN;WADdC,aA0BWC,mBA1BX,EA0BW;mBAAA;MAxBTC,GAAG,EAAC,SAwBK;MAvBRC,GAAG,EAAEJ,CAAC,MAAD,GAAUf,cAuBP;MAtBRD,KAAK,+CAA8BgB,CAA9B,GACA,OADA,EAsBG;MApBRd,KAAK,mBAAGG,kBAAH,EAAcA,oBAAd,EAA2BA,mBAA3B,EAAuCW,CAAvC,EAoBG;MAnBR,aAAW,EAmBH;MAlBRK,MAAM,EAAOpB,mBAkBL;MAjBR,iBAAee,CAiBP;MAhBR,gBAAcf,wBAAkBA,iBAAWe,CAAX,GAAY,CAA9B,KAA8B,CAgBpC;MAfRM,KAAK,EAAEnB,YAeC;MAdR,mBAAiBA,qBAcT;MAbR,qBAAmBA,uBAaX;MAZR,wBAAsBA,wBAYd;MAXR,uBAAqBA,uBAWb;MAVRoB,OAAK,EAAElB;IAUC,CA1BX;wBAkBE,MAOC,CANOJ,iBAAWe,CAAX,GAAY,CAAZ,GAAY,EAAZ,IAAyBf,iBAAWe,CAAX,GAAY,CAAZ,GAAmBb,YAAKqB,wBADzDZ,oBAOC,KAPD,EAOC;cAAA;QALEa,GAAG,EAAEtB,YAAKF,iBAAWe,CAAX,GAAY,CAAjB,CAKP;QAJCU,SAAS,EAAC,OAIX;QAHCxB,KAAuD,EAAvD;UAAA;UAAA;UAAA;QAAA,CAGD;QAFEyB,MAAI,YAAEtB,qBAAYJ,iBAAWe,CAAX,GAAY,CAAxB,EAA8BY,MAA9B,CAER;QADEC,WAAS,yCAAExB,+DAAF;MACX,CAPD;;MAAA,kDAOC;;;;KAzBH;;IAAA;GA0BW,CA1BX;;EAAA,GAhBF;;EAAA","names":["_createCommentVNode","_createElementVNode","class","$data","style","$props","onMousemove","$options","onMousedown","onMouseout","onMouseup","onTouchstart","onTouchend","onTouchmove","_createElementBlock","_Fragment","_renderList","n","i","_createVNode","_component_v_zoomer","ref","key","zoomed","pivot","onSwipe","length","src","draggable","onLoad","$event","onDragstart"],"sourceRoot":"","sources":["Q:\\Projects\\Transport-web\\node_modules\\vue-zoomer\\src\\vue-zoomer-gallery.vue"],"sourcesContent":["<template>\n  <!-- touchmove.prevent is used to stop the page scroll elastic effects -->\n  <div\n    :class=\"{\n      'anim': autoSliding && !isPointerDown,\n    }\"\n    :style=\"{\n      'background-color': backgroundColor,\n    }\"\n    class=\"vue-zoomer-gallery\"\n    @mousemove=\"onMouseMove\"\n    @mousedown=\"onMouseDown\"\n    @mouseout=\"onMouseUp\"\n    @mouseup=\"onMouseUp\"\n    @touchstart=\"onTouchStart\"\n    @touchend=\"onTouchEnd\"\n    @touchmove.prevent=\"onTouchMove\"\n  >\n    <v-zoomer\n      v-for=\"(n, i) in 3\"\n      ref=\"zoomers\"\n      :key=\"i + '-' + selIndex\"\n      :class=\"['left', 'middle', 'right'][i]\"\n      class=\"slide\"\n      :style=\"[leftStyle, middleStyle, rightStyle][i]\"\n      :max-scale=\"10\"\n      :zoomed.sync=\"currentZoomed\"\n      :reset-trigger=\"i\"\n      :aspect-ratio=\"imageAspectRatios[selIndex + i - 1] || 1\"\n      :pivot=\"pivot\"\n      :zooming-elastic=\"zoomingElastic\"\n      :limit-translation=\"limitTranslation\"\n      :double-click-to-zoom=\"doubleClickToZoom\"\n      :mouse-wheel-to-zoom=\"mouseWheelToZoom\"\n      @swipe=\"onImageSwipe\"\n    >\n      <img\n        v-if=\"selIndex + i - 1 > -1 && selIndex + i - 1 < list.length\"\n        :src=\"list[selIndex + i - 1]\"\n        draggable=\"false\"\n        style=\"object-fit: contain; width: 100%; height: 100%;\"\n        @load=\"onImageLoad(selIndex + i - 1, $event)\"\n        @dragstart=\"onImageDragStart\"\n      >\n    </v-zoomer>\n  </div>\n</template>\n\n<script>\n\nconst SLIDE_WIDTH_THRESH = 50 // in px\n\nexport default {\n  props: {\n    value: { type: Number, required: true },\n    list: { type: Array, required: true },\n    backgroundColor: { type: String, default: '#333' },\n    pivot: { type: String, default: 'cursor' },\n    zoomingElastic: { type: Boolean, default: true },\n    limitTranslation: { type: Boolean, default: true },\n    doubleClickToZoom: { type: Boolean, default: true },\n    mouseWheelToZoom: { type: Boolean, default: true },\n  },\n  data () {\n    return {\n      // env states\n      containerWidth: 1,\n      containerHeight: 1,\n      // main states\n      selIndex: this.value,\n      animSelIndex: this.value,\n      currentZoomed: false,\n      autoSliding: false,\n      imageAspectRatios: [], // aspect ratio (width / height) of images\n      // interaction states\n      isPointerDown: false,\n      lastPointerX: 0,\n      slideOffsetX: 0,\n    }\n  },\n  computed: {\n    middleStyle () {\n      return {\n        left: `${ 0 + this.slideOffsetX }px`,\n      }\n    },\n    leftStyle () {\n      return {\n        left: `${ -this.containerWidth + this.slideOffsetX }px`,\n      }\n    },\n    rightStyle () {\n      return {\n        left: `${ this.containerWidth + this.slideOffsetX }px`,\n      }\n    },\n    slideThresh () {\n      return Math.max(SLIDE_WIDTH_THRESH, this.containerWidth * 0.1)\n    },\n  },\n  watch: {\n    value (val) {\n      if (val !== this.animSelIndex) {\n        this.selIndex = val\n        this.animSelIndex = val\n      }\n    },\n    selIndex() {\n      this.$nextTick(() => {\n        this.$refs.zoomers.forEach(zoomer => {\n          zoomer.refreshContainerPos()\n        })\n      })\n    },\n  },\n  mounted () {\n    window.addEventListener('resize', this.onWindowResize)\n    this.onWindowResize()\n  },\n  destroyed () {\n    window.removeEventListener('resize', this.onWindowResize)\n  },\n  methods: {\n    // api ---------------------------------------------------------------------\n    reset () {\n      this.$refs.zoomers.forEach(zoomer => {\n        zoomer.reset()\n      })\n    },\n    zoomIn (scale) {\n      if (this.$refs.zoomers[1]) this.$refs.zoomers[1].zoomIn(scale)\n    },\n    zoomOut (scale) {\n      if (this.$refs.zoomers[1]) this.$refs.zoomers[1].zoomOut(scale)\n    },\n    // events ------------------------------------------------------------------\n    onWindowResize () {\n      let styles = window.getComputedStyle(this.$el)\n      this.containerWidth = parseFloat(styles.width)\n      this.containerHeight = parseFloat(styles.height)\n    },\n    onPointerMove (deltaX) {\n      if (this.isPointerDown && !this.currentZoomed) {\n        let factor = (\n          (this.selIndex === 0 && deltaX > 0 && this.slideOffsetX + deltaX > 0) ||\n          (this.selIndex === this.list.length - 1 && deltaX < 0 && this.slideOffsetX + deltaX < 0)\n        ) ? 0.3 : 1\n        this.slideOffsetX += deltaX * factor\n      }\n    },\n    onPointerUp () {\n      if (this.slideOffsetX < -this.slideThresh) {\n        // next page\n        this.paginate(1)\n      } else if (this.slideOffsetX > this.slideThresh) {\n        // prev page\n        this.paginate(-1)\n      } else {\n        // only apply the animation\n        this.paginate(0)\n      }\n    },\n    // Stop Firefox dragging the image\n    onImageDragStart(ev) {\n      ev.preventDefault();\n      return false\n    },\n    paginate (deltaIndex) {\n      let targetIndex = this.selIndex + deltaIndex\n      if (targetIndex < 0 || targetIndex >= this.list.length) {\n        this.slideOffsetX = 0\n        return\n      }\n\n      this.slideOffsetX = this.containerWidth * -deltaIndex\n      this.autoSliding = true\n      // update the selIndex before the animation to remove the delay feeling\n      this.$emit('input', targetIndex)\n      this.animSelIndex = targetIndex\n      setTimeout(() => {\n        this.selIndex = targetIndex\n        this.slideOffsetX = 0\n        this.autoSliding = false\n      }, 400)\n    },\n    onMouseDown (ev) {\n      this.isPointerDown = true\n      this.lastPointerX = ev.clientX\n    },\n    onMouseUp (ev) {\n      this.isPointerDown = false\n      this.onPointerUp()\n    },\n    onMouseMove (ev) {\n      if (this.isPointerDown) {\n        this.onPointerMove(ev.clientX - this.lastPointerX)\n        this.lastPointerX = ev.clientX\n      }\n    },\n    onTouchStart (ev) {\n      if (ev.touches.length === 1) {\n        this.isPointerDown = true\n        this.lastPointerX = ev.touches[0].clientX\n      }\n    },\n    onTouchEnd (ev) {\n      if (ev.touches.length === 0) {\n        this.isPointerDown = false\n        this.onPointerUp()\n      }\n    },\n    onTouchMove (ev) {\n      if (ev.touches.length === 1) {\n        this.onPointerMove(ev.touches[0].clientX - this.lastPointerX)\n        this.lastPointerX = ev.touches[0].clientX\n      }\n    },\n    onImageLoad (index, ev) {\n      let aspectRatio = ev.target.naturalWidth / ev.target.naturalHeight\n      this.$set(this.imageAspectRatios, index, aspectRatio)\n    },\n    onImageSwipe (direction) {\n      this.paginate(direction == 'right' ? -1 : 1)\n    },\n  },\n}\n</script>\n\n<style scoped>\n.vue-zoomer-gallery {\n  position: relative;\n  overflow: hidden;\n  user-select: none;\n  min-width: 100px;\n  min-height: 100px;\n}\n.vue-zoomer-gallery > * {\n  display: inline-block;\n}\n.vue-zoomer-gallery.anim .slide {\n  transition: left 0.4s;\n}\n\n.slide {\n  position: absolute;\n  top: 0;\n  object-fit: contain;\n  width: 100%;\n  height: 100%;\n  -webkit-user-drag: none;\n}\n</style>\n"]},"metadata":{},"sourceType":"module"}