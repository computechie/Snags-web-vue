{"ast":null,"code":"import _debounce from './debounce.min.js';\nimport TapDetector from './TapDetector';\nexport default {\n  props: {\n    minScale: {\n      type: Number,\n      default: 1\n    },\n    maxScale: {\n      type: Number,\n      default: 5\n    },\n    zoomed: {\n      type: Boolean,\n      default: false\n    },\n    resetTrigger: {\n      type: Number,\n      default: 1e5\n    },\n    aspectRatio: {\n      type: Number,\n      default: 1\n    },\n    backgroundColor: {\n      type: String,\n      default: 'transparent'\n    },\n    pivot: {\n      type: String,\n      default: 'cursor'\n    },\n    // other options: image-center\n    zoomingElastic: {\n      type: Boolean,\n      default: true\n    },\n    limitTranslation: {\n      type: Boolean,\n      default: true\n    },\n    doubleClickToZoom: {\n      type: Boolean,\n      default: true\n    },\n    mouseWheelToZoom: {\n      type: Boolean,\n      default: true\n    }\n  },\n\n  data() {\n    return {\n      // Container sizes, used to determin the initial zoomer size.\n      // Need to reactive to window resizing.\n      containerWidth: 1,\n      containerHeight: 1,\n      containerLeft: 0,\n      containerTop: 0,\n      // Store values: Interactions will at last change these values.\n      // After rotation or resize, these values will keep still.\n      // These three values are all relative to the container size.\n      translateX: 0,\n      animTranslateX: 0,\n      translateY: 0,\n      animTranslateY: 0,\n      scale: 1,\n      animScale: 1,\n      // Mouse states\n      lastFullWheelTime: 0,\n      lastWheelTime: 0,\n      lastWheelDirection: 'y',\n      isPointerDown: false,\n      pointerPosX: -1,\n      pointerPosY: -1,\n      twoFingerInitDist: 0,\n      panLocked: true,\n      // Others\n      raf: null,\n      tapDetector: null\n    };\n  },\n\n  computed: {\n    wrapperStyle() {\n      let translateX = this.containerWidth * this.animTranslateX;\n      let translateY = this.containerHeight * this.animTranslateY;\n      return {\n        transform: [`translate(${translateX}px, ${translateY}px)`, `scale(${this.animScale})`].join(' ')\n      };\n    }\n\n  },\n  watch: {\n    scale(val) {\n      if (val !== 1) {\n        this.$emit('update:zoomed', true);\n        this.panLocked = false;\n      }\n    },\n\n    resetTrigger: 'reset'\n  },\n\n  mounted() {\n    this.tapDetector = new TapDetector();\n    this.tapDetector.attach(this.$el);\n\n    if (this.doubleClickToZoom) {\n      this.tapDetector.onDoubleTap(this.onDoubleTap);\n    } // console.log('container size: ', this.containerWidth, this.containerHeight)\n\n\n    window.addEventListener('resize', this.onWindowResize);\n    this.onWindowResize();\n    this.refreshContainerPos();\n    this.loop();\n  },\n\n  destroyed() {\n    this.tapDetector.detach(this.$el);\n    window.removeEventListener('resize', this.onWindowResize);\n    window.cancelAnimationFrame(this.raf); // console.log('destroy')\n  },\n\n  methods: {\n    // API ---------------------------------------------------------------------\n    reset() {\n      this.scale = 1;\n      this.panLocked = true;\n      this.translateX = 0;\n      this.translateY = 0;\n    },\n\n    zoomIn(scale = 2) {\n      this.tryToScale(scale);\n      this.onInteractionEnd();\n    },\n\n    zoomOut(scale = 0.5) {\n      this.tryToScale(scale);\n      this.onInteractionEnd();\n    },\n\n    // Main Logic --------------------------------------------------------------\n    // scale\n    // Zoom the image with the point at the pointer(mouse or pinch center) pinned.\n    // Simplify: This can be regard as vector pointer to old-image-center scaling.\n    tryToScale(scaleDelta) {\n      let newScale = this.scale * scaleDelta;\n\n      if (this.zoomingElastic) {\n        // damping\n        if (newScale < this.minScale || newScale > this.maxScale) {\n          let log = Math.log2(scaleDelta);\n          log *= 0.2;\n          scaleDelta = Math.pow(2, log);\n          newScale = this.scale * scaleDelta;\n        }\n      } else {\n        if (newScale < this.minScale) newScale = this.minScale;else if (newScale > this.maxScale) newScale = this.maxScale;\n      }\n\n      scaleDelta = newScale / this.scale;\n      this.scale = newScale;\n\n      if (this.pivot !== 'image-center') {\n        let normMousePosX = (this.pointerPosX - this.containerLeft) / this.containerWidth;\n        let normMousePosY = (this.pointerPosY - this.containerTop) / this.containerHeight;\n        this.translateX = (0.5 + this.translateX - normMousePosX) * scaleDelta + normMousePosX - 0.5;\n        this.translateY = (0.5 + this.translateY - normMousePosY) * scaleDelta + normMousePosY - 0.5;\n      }\n    },\n\n    setPointerPosCenter() {\n      this.pointerPosX = this.containerLeft + this.containerWidth / 2;\n      this.pointerPosY = this.containerTop + this.containerHeight / 2;\n    },\n\n    // pan\n    onPointerMove(newMousePosX, newMousePosY) {\n      if (this.isPointerDown) {\n        let pixelDeltaX = newMousePosX - this.pointerPosX;\n        let pixelDeltaY = newMousePosY - this.pointerPosY; // console.log('pixelDeltaX, pixelDeltaY', pixelDeltaX, pixelDeltaY)\n\n        if (!this.panLocked) {\n          this.translateX += pixelDeltaX / this.containerWidth;\n          this.translateY += pixelDeltaY / this.containerHeight;\n        }\n      }\n\n      this.pointerPosX = newMousePosX;\n      this.pointerPosY = newMousePosY;\n    },\n\n    onInteractionEnd: _debounce(function () {\n      this.limit();\n      this.panLocked = this.scale === 1;\n      this.$emit('update:zoomed', !this.panLocked);\n    }, 100),\n\n    // limit the scale between max and min and the translate within the viewport\n    limit() {\n      // scale\n      if (this.scale < this.minScale) {\n        this.scale = this.minScale; // FIXME this sometimes will not reset when pinching in\n        // this.tryToScale(this.minScale / this.scale)\n      } else if (this.scale > this.maxScale) {\n        this.tryToScale(this.maxScale / this.scale);\n      } // translate\n\n\n      if (this.limitTranslation) {\n        let translateLimit = this.calcTranslateLimit();\n\n        if (Math.abs(this.translateX) > translateLimit.x) {\n          this.translateX *= translateLimit.x / Math.abs(this.translateX);\n        }\n\n        if (Math.abs(this.translateY) > translateLimit.y) {\n          this.translateY *= translateLimit.y / Math.abs(this.translateY);\n        }\n      }\n    },\n\n    calcTranslateLimit() {\n      if (this.getMarginDirection() === 'y') {\n        let imageToContainerRatio = this.containerWidth / this.aspectRatio / this.containerHeight;\n        let translateLimitY = (this.scale * imageToContainerRatio - 1) / 2;\n        if (translateLimitY < 0) translateLimitY = 0;\n        return {\n          x: (this.scale - 1) / 2,\n          y: translateLimitY\n        };\n      } else {\n        let imageToContainerRatio = this.containerHeight * this.aspectRatio / this.containerWidth;\n        let translateLimitX = (this.scale * imageToContainerRatio - 1) / 2;\n        if (translateLimitX < 0) translateLimitX = 0;\n        return {\n          x: translateLimitX,\n          y: (this.scale - 1) / 2\n        };\n      }\n    },\n\n    getMarginDirection() {\n      let containerRatio = this.containerWidth / this.containerHeight;\n      return containerRatio > this.aspectRatio ? 'x' : 'y';\n    },\n\n    onDoubleTap(ev) {\n      if (this.scale === 1) {\n        if (ev.clientX > 0) {\n          this.pointerPosX = ev.clientX;\n          this.pointerPosY = ev.clientY;\n        }\n\n        this.tryToScale(Math.min(3, this.maxScale));\n      } else {\n        this.reset();\n      }\n\n      this.onInteractionEnd();\n    },\n\n    // reactive\n    onWindowResize() {\n      let styles = window.getComputedStyle(this.$el);\n      this.containerWidth = parseFloat(styles.width);\n      this.containerHeight = parseFloat(styles.height);\n      this.setPointerPosCenter();\n      this.limit();\n    },\n\n    refreshContainerPos() {\n      let rect = this.$el.getBoundingClientRect();\n      this.containerLeft = rect.left;\n      this.containerTop = rect.top;\n    },\n\n    loop() {\n      this.animScale = this.gainOn(this.animScale, this.scale);\n      this.animTranslateX = this.gainOn(this.animTranslateX, this.translateX);\n      this.animTranslateY = this.gainOn(this.animTranslateY, this.translateY);\n      this.raf = window.requestAnimationFrame(this.loop); // console.log('loop', this.raf)\n    },\n\n    gainOn(from, to) {\n      let delta = (to - from) * 0.3; // console.log('gainOn', from, to, from + delta)\n\n      if (Math.abs(delta) > 1e-5) {\n        return from + delta;\n      } else {\n        return to;\n      }\n    },\n\n    // Mouse Events ------------------------------------------------------------\n    // Mouse wheel scroll,  TrackPad pinch or TrackPad scroll\n    onMouseWheel(ev) {\n      if (!this.mouseWheelToZoom) return; // prevent is used to stop the page scroll elastic effects\n\n      ev.preventDefault();\n      if (ev.detail) ev.wheelDelta = ev.detail * -10;\n      let currTime = Date.now();\n\n      if (Math.abs(ev.wheelDelta) === 120) {\n        // Throttle the TouchPad pinch on Mac, or it will be too sensitive\n        if (currTime - this.lastFullWheelTime > 50) {\n          this.onMouseWheelDo(ev.wheelDelta);\n          this.lastFullWheelTime = currTime;\n        }\n      } else {\n        if (currTime - this.lastWheelTime > 50 && typeof ev.deltaX === 'number') {\n          this.lastWheelDirection = ev.detail == 0 && Math.abs(ev.deltaX) > Math.abs(ev.deltaY) ? 'x' : 'y';\n\n          if (this.lastWheelDirection === 'x') {\n            this.$emit('swipe', ev.deltaX > 0 ? 'left' : 'right');\n          }\n        }\n\n        if (this.lastWheelDirection === 'y') {\n          this.onMouseWheelDo(ev.wheelDelta);\n        }\n      }\n\n      this.lastWheelTime = currTime;\n    },\n\n    onMouseWheelDo(wheelDelta) {\n      // Value basis: One mouse wheel (wheelDelta=+-120) means 1.25/0.8 scale.\n      let scaleDelta = Math.pow(1.25, wheelDelta / 120);\n      this.tryToScale(scaleDelta);\n      this.onInteractionEnd();\n    },\n\n    onMouseDown(ev) {\n      this.refreshContainerPos();\n      this.isPointerDown = true; // Open the context menu then click other place will skip the mousemove events.\n      // This will cause the pointerPosX/Y NOT sync, then we will need to fix it on mousedown event.\n\n      this.pointerPosX = ev.clientX;\n      this.pointerPosY = ev.clientY; // console.log('onMouseDown', ev)\n    },\n\n    onMouseUp(ev) {\n      this.isPointerDown = false;\n      this.onInteractionEnd();\n    },\n\n    onMouseMove(ev) {\n      this.onPointerMove(ev.clientX, ev.clientY); // console.log('onMouseMove client, offset', ev.clientX, ev.clientY)\n    },\n\n    // Touch Events ------------------------------------------------------------\n    onTouchStart(ev) {\n      if (ev.touches.length === 1) {\n        this.refreshContainerPos();\n        this.pointerPosX = ev.touches[0].clientX;\n        this.pointerPosY = ev.touches[0].clientY;\n        this.isPointerDown = true;\n      } else if (ev.touches.length === 2) {\n        this.isPointerDown = true; // pos\n\n        this.pointerPosX = (ev.touches[0].clientX + ev.touches[1].clientX) / 2;\n        this.pointerPosY = (ev.touches[0].clientY + ev.touches[1].clientY) / 2; // dist\n\n        let distX = ev.touches[0].clientX - ev.touches[1].clientX;\n        let distY = ev.touches[0].clientY - ev.touches[1].clientY;\n        this.twoFingerInitDist = Math.sqrt(distX * distX + distY * distY);\n      } // console.log('onTouchStart', ev.touches)\n\n    },\n\n    onTouchEnd(ev) {\n      if (ev.touches.length === 0) {\n        this.isPointerDown = false; // Near 1 to set 1\n\n        if (Math.abs(this.scale - 1) < 0.1) this.scale = 1;\n        this.onInteractionEnd();\n      } else if (ev.touches.length === 1) {\n        this.pointerPosX = ev.touches[0].clientX;\n        this.pointerPosY = ev.touches[0].clientY;\n      } // console.log('onTouchEnd', ev.touches.length)\n\n    },\n\n    onTouchMove(ev) {\n      if (ev.touches.length === 1) {\n        this.onPointerMove(ev.touches[0].clientX, ev.touches[0].clientY);\n      } else if (ev.touches.length === 2) {\n        // pos\n        let newMousePosX = (ev.touches[0].clientX + ev.touches[1].clientX) / 2;\n        let newMousePosY = (ev.touches[0].clientY + ev.touches[1].clientY) / 2;\n        this.onPointerMove(newMousePosX, newMousePosY);\n        this.pointerPosX = newMousePosX;\n        this.pointerPosY = newMousePosY; // dist\n\n        let distX = ev.touches[0].clientX - ev.touches[1].clientX;\n        let distY = ev.touches[0].clientY - ev.touches[1].clientY;\n        let newTwoFingerDist = Math.sqrt(distX * distX + distY * distY);\n        this.tryToScale(newTwoFingerDist / this.twoFingerInitDist);\n        this.twoFingerInitDist = newTwoFingerDist;\n      } // console.log('onTouchMove', this.pointerPosX, this.pointerPosY)\n\n    }\n\n  }\n};","map":{"version":3,"mappings":"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","names":["_debounce","TapDetector","props","minScale","type","Number","default","maxScale","zoomed","Boolean","resetTrigger","aspectRatio","backgroundColor","String","pivot","zoomingElastic","limitTranslation","doubleClickToZoom","mouseWheelToZoom","data","containerWidth","containerHeight","containerLeft","containerTop","translateX","animTranslateX","translateY","animTranslateY","scale","animScale","lastFullWheelTime","lastWheelTime","lastWheelDirection","isPointerDown","pointerPosX","pointerPosY","twoFingerInitDist","panLocked","raf","tapDetector","computed","wrapperStyle","transform","join","watch","val","$emit","mounted","attach","$el","onDoubleTap","window","addEventListener","onWindowResize","refreshContainerPos","loop","destroyed","detach","removeEventListener","cancelAnimationFrame","methods","reset","zoomIn","tryToScale","onInteractionEnd","zoomOut","scaleDelta","newScale","log","Math","log2","pow","normMousePosX","normMousePosY","setPointerPosCenter","onPointerMove","newMousePosX","newMousePosY","pixelDeltaX","pixelDeltaY","limit","translateLimit","calcTranslateLimit","abs","x","y","getMarginDirection","imageToContainerRatio","translateLimitY","translateLimitX","containerRatio","ev","clientX","clientY","min","styles","getComputedStyle","parseFloat","width","height","rect","getBoundingClientRect","left","top","gainOn","requestAnimationFrame","from","to","delta","onMouseWheel","preventDefault","detail","wheelDelta","currTime","Date","now","onMouseWheelDo","deltaX","deltaY","onMouseDown","onMouseUp","onMouseMove","onTouchStart","touches","length","distX","distY","sqrt","onTouchEnd","onTouchMove","newTwoFingerDist"],"sourceRoot":"","sources":["Q:\\Projects\\Transport-web\\node_modules\\vue-zoomer\\src\\vue-zoomer.vue"],"sourcesContent":["<!-- vue-zoomer: https://github.com/jarvisniu/vue-zoomer -->\n<template>\n  <div\n    class=\"vue-zoomer\"\n    :style=\"{backgroundColor: backgroundColor}\"\n    @mousewheel=\"onMouseWheel\"\n    @DOMMouseScroll=\"onMouseWheel\"\n    @mousedown=\"onMouseDown\"\n    @mouseup=\"onMouseUp\"\n    @mousemove=\"onMouseMove\"\n    @mouseout=\"setPointerPosCenter\"\n    @touchstart=\"onTouchStart\"\n    @touchend=\"onTouchEnd\"\n    @touchmove=\"onTouchMove\"\n  >\n    <div class=\"zoomer\" :style=\"wrapperStyle\">\n      <slot></slot>\n    </div>\n  </div>\n</template>\n\n<script>\nimport _debounce from './debounce.min.js'\n\nimport TapDetector from './TapDetector'\n\nexport default {\n  props: {\n    minScale: { type: Number, default: 1 },\n    maxScale: { type: Number, default: 5 },\n    zoomed: { type: Boolean, default: false },\n    resetTrigger: { type: Number, default: 1e5 },\n    aspectRatio: { type: Number, default: 1 },\n    backgroundColor: { type: String, default: 'transparent' },\n    pivot: { type: String, default: 'cursor' }, // other options: image-center\n    zoomingElastic: { type: Boolean, default: true },\n    limitTranslation: { type: Boolean, default: true },\n    doubleClickToZoom: { type: Boolean, default: true },\n    mouseWheelToZoom: { type: Boolean, default: true },\n  },\n  data () {\n    return {\n      // Container sizes, used to determin the initial zoomer size.\n      // Need to reactive to window resizing.\n      containerWidth: 1,\n      containerHeight: 1,\n      containerLeft: 0,\n      containerTop: 0,\n      // Store values: Interactions will at last change these values.\n      // After rotation or resize, these values will keep still.\n      // These three values are all relative to the container size.\n      translateX: 0,\n      animTranslateX: 0,\n      translateY: 0,\n      animTranslateY: 0,\n      scale: 1,\n      animScale: 1,\n      // Mouse states\n      lastFullWheelTime: 0,\n      lastWheelTime: 0,\n      lastWheelDirection: 'y',\n      isPointerDown: false,\n      pointerPosX: -1,\n      pointerPosY: -1,\n      twoFingerInitDist: 0,\n      panLocked: true,\n      // Others\n      raf: null,\n      tapDetector: null,\n    }\n  },\n  computed: {\n    wrapperStyle () {\n      let translateX = this.containerWidth * this.animTranslateX\n      let translateY = this.containerHeight * this.animTranslateY\n      return {\n        transform: [\n          `translate(${ translateX }px, ${ translateY }px)`,\n          `scale(${ this.animScale })`,\n        ].join(' ')\n      }\n    },\n  },\n  watch: {\n    scale (val) {\n      if (val !== 1) {\n        this.$emit('update:zoomed', true)\n        this.panLocked = false\n      }\n    },\n    resetTrigger: 'reset',\n  },\n  mounted () {\n    this.tapDetector = new TapDetector()\n    this.tapDetector.attach(this.$el)\n    if (this.doubleClickToZoom) {\n      this.tapDetector.onDoubleTap(this.onDoubleTap)\n    }\n    // console.log('container size: ', this.containerWidth, this.containerHeight)\n    window.addEventListener('resize', this.onWindowResize)\n    this.onWindowResize()\n    this.refreshContainerPos()\n    this.loop()\n  },\n  destroyed () {\n    this.tapDetector.detach(this.$el)\n    window.removeEventListener('resize', this.onWindowResize)\n    window.cancelAnimationFrame(this.raf)\n    // console.log('destroy')\n  },\n  methods: {\n    // API ---------------------------------------------------------------------\n    reset () {\n      this.scale = 1\n      this.panLocked = true\n      this.translateX = 0\n      this.translateY = 0\n    },\n    zoomIn(scale = 2) {\n      this.tryToScale(scale)\n      this.onInteractionEnd()\n    },\n    zoomOut(scale = 0.5) {\n      this.tryToScale(scale)\n      this.onInteractionEnd()\n    },\n    // Main Logic --------------------------------------------------------------\n    // scale\n    // Zoom the image with the point at the pointer(mouse or pinch center) pinned.\n    // Simplify: This can be regard as vector pointer to old-image-center scaling.\n    tryToScale (scaleDelta) {\n      let newScale = this.scale * scaleDelta\n      if (this.zoomingElastic) {\n        // damping\n        if (newScale < this.minScale || newScale > this.maxScale) {\n          let log = Math.log2(scaleDelta)\n          log *= 0.2\n          scaleDelta = Math.pow(2, log)\n          newScale = this.scale * scaleDelta\n        }\n      } else {\n        if (newScale < this.minScale) newScale = this.minScale\n        else if (newScale > this.maxScale) newScale = this.maxScale\n      }\n      scaleDelta = newScale / this.scale\n      this.scale = newScale\n      if (this.pivot !== 'image-center') {\n        let normMousePosX = (this.pointerPosX - this.containerLeft) / this.containerWidth\n        let normMousePosY = (this.pointerPosY - this.containerTop) / this.containerHeight\n        this.translateX = (0.5 + this.translateX - normMousePosX) * scaleDelta + normMousePosX - 0.5\n        this.translateY = (0.5 + this.translateY - normMousePosY) * scaleDelta + normMousePosY - 0.5\n      }\n    },\n    setPointerPosCenter () {\n      this.pointerPosX = this.containerLeft + this.containerWidth / 2\n      this.pointerPosY = this.containerTop + this.containerHeight / 2\n    },\n    // pan\n    onPointerMove (newMousePosX, newMousePosY) {\n      if (this.isPointerDown) {\n        let pixelDeltaX = newMousePosX - this.pointerPosX\n        let pixelDeltaY = newMousePosY - this.pointerPosY\n        // console.log('pixelDeltaX, pixelDeltaY', pixelDeltaX, pixelDeltaY)\n        if (!this.panLocked) {\n          this.translateX += pixelDeltaX / this.containerWidth\n          this.translateY += pixelDeltaY / this.containerHeight\n        }\n      }\n      this.pointerPosX = newMousePosX\n      this.pointerPosY = newMousePosY\n    },\n    onInteractionEnd: _debounce(function ()  {\n      this.limit()\n      this.panLocked = this.scale === 1\n      this.$emit('update:zoomed', !this.panLocked)\n    }, 100),\n    // limit the scale between max and min and the translate within the viewport\n    limit () {\n      // scale\n      if (this.scale < this.minScale) {\n        this.scale = this.minScale\n        // FIXME this sometimes will not reset when pinching in\n        // this.tryToScale(this.minScale / this.scale)\n      } else if (this.scale > this.maxScale) {\n        this.tryToScale(this.maxScale / this.scale)\n      }\n      // translate\n      if (this.limitTranslation) {\n        let translateLimit = this.calcTranslateLimit()\n        if (Math.abs(this.translateX) > translateLimit.x) {\n          this.translateX *= translateLimit.x / Math.abs(this.translateX)\n        }\n        if (Math.abs(this.translateY) > translateLimit.y) {\n          this.translateY *= translateLimit.y / Math.abs(this.translateY)\n        }\n      }\n    },\n    calcTranslateLimit () {\n      if (this.getMarginDirection() === 'y') {\n        let imageToContainerRatio = this.containerWidth / this.aspectRatio / this.containerHeight\n        let translateLimitY = (this.scale * imageToContainerRatio - 1) / 2\n        if (translateLimitY < 0) translateLimitY = 0\n        return {\n          x: (this.scale - 1) / 2,\n          y: translateLimitY,\n        }\n      } else {\n        let imageToContainerRatio = this.containerHeight * this.aspectRatio / this.containerWidth\n        let translateLimitX = (this.scale * imageToContainerRatio - 1) / 2\n        if (translateLimitX < 0) translateLimitX = 0\n        return {\n          x: translateLimitX,\n          y: (this.scale - 1) / 2,\n        }\n      }\n    },\n    getMarginDirection () {\n      let containerRatio = this.containerWidth / this.containerHeight\n      return containerRatio > this.aspectRatio ? 'x' : 'y'\n    },\n    onDoubleTap (ev) {\n      if (this.scale === 1) {\n        if (ev.clientX > 0) {\n          this.pointerPosX = ev.clientX\n          this.pointerPosY = ev.clientY\n        }\n        this.tryToScale(Math.min(3, this.maxScale))\n      } else {\n        this.reset()\n      }\n      this.onInteractionEnd()\n    },\n    // reactive\n    onWindowResize () {\n      let styles = window.getComputedStyle(this.$el)\n      this.containerWidth = parseFloat(styles.width)\n      this.containerHeight = parseFloat(styles.height)\n      this.setPointerPosCenter()\n      this.limit()\n    },\n    refreshContainerPos () {\n      let rect = this.$el.getBoundingClientRect()\n      this.containerLeft = rect.left\n      this.containerTop = rect.top\n    },\n    loop () {\n      this.animScale = this.gainOn(this.animScale, this.scale)\n      this.animTranslateX = this.gainOn(this.animTranslateX, this.translateX)\n      this.animTranslateY = this.gainOn(this.animTranslateY, this.translateY)\n      this.raf = window.requestAnimationFrame(this.loop)\n      // console.log('loop', this.raf)\n    },\n    gainOn (from, to) {\n      let delta = (to - from) * 0.3\n      // console.log('gainOn', from, to, from + delta)\n      if (Math.abs(delta) > 1e-5) {\n        return from + delta\n      } else {\n        return to\n      }\n    },\n    // Mouse Events ------------------------------------------------------------\n    // Mouse wheel scroll,  TrackPad pinch or TrackPad scroll\n    onMouseWheel (ev) {\n      if (!this.mouseWheelToZoom) return\n      // prevent is used to stop the page scroll elastic effects\n      ev.preventDefault()\n      if (ev.detail) ev.wheelDelta = ev.detail * -10\n      let currTime = Date.now()\n      if (Math.abs(ev.wheelDelta) === 120) {\n        // Throttle the TouchPad pinch on Mac, or it will be too sensitive\n        if (currTime - this.lastFullWheelTime > 50) {\n          this.onMouseWheelDo(ev.wheelDelta)\n          this.lastFullWheelTime = currTime\n        }\n      } else {\n        if (currTime - this.lastWheelTime > 50 && typeof ev.deltaX === 'number') {\n          this.lastWheelDirection = (ev.detail == 0 && Math.abs(ev.deltaX) > Math.abs(ev.deltaY)) ? 'x' : 'y'\n          if (this.lastWheelDirection === 'x') {\n            this.$emit('swipe', ev.deltaX > 0 ? 'left' : 'right')\n          }\n        }\n        if (this.lastWheelDirection === 'y') {\n          this.onMouseWheelDo(ev.wheelDelta)\n        }\n      }\n      this.lastWheelTime = currTime\n    },\n    onMouseWheelDo (wheelDelta) {\n      // Value basis: One mouse wheel (wheelDelta=+-120) means 1.25/0.8 scale.\n      let scaleDelta = Math.pow(1.25, wheelDelta / 120)\n      this.tryToScale(scaleDelta)\n      this.onInteractionEnd()\n    },\n    onMouseDown (ev) {\n      this.refreshContainerPos()\n      this.isPointerDown = true\n      // Open the context menu then click other place will skip the mousemove events.\n      // This will cause the pointerPosX/Y NOT sync, then we will need to fix it on mousedown event.\n      this.pointerPosX = ev.clientX\n      this.pointerPosY = ev.clientY\n      // console.log('onMouseDown', ev)\n    },\n    onMouseUp (ev) {\n      this.isPointerDown = false\n      this.onInteractionEnd()\n    },\n    onMouseMove (ev) {\n      this.onPointerMove(ev.clientX, ev.clientY)\n      // console.log('onMouseMove client, offset', ev.clientX, ev.clientY)\n    },\n    // Touch Events ------------------------------------------------------------\n    onTouchStart (ev) {\n      if (ev.touches.length === 1) {\n        this.refreshContainerPos()\n        this.pointerPosX = ev.touches[0].clientX\n        this.pointerPosY = ev.touches[0].clientY\n        this.isPointerDown = true\n      } else if (ev.touches.length === 2) {\n        this.isPointerDown = true\n        // pos\n        this.pointerPosX = (ev.touches[0].clientX + ev.touches[1].clientX) / 2\n        this.pointerPosY = (ev.touches[0].clientY + ev.touches[1].clientY) / 2\n        // dist\n        let distX = ev.touches[0].clientX - ev.touches[1].clientX\n        let distY = ev.touches[0].clientY - ev.touches[1].clientY\n        this.twoFingerInitDist = Math.sqrt(distX * distX + distY * distY)\n      }\n      // console.log('onTouchStart', ev.touches)\n    },\n    onTouchEnd (ev) {\n      if (ev.touches.length === 0) {\n        this.isPointerDown = false\n        // Near 1 to set 1\n        if (Math.abs(this.scale - 1) < 0.1) this.scale = 1\n        this.onInteractionEnd()\n      } else if (ev.touches.length === 1) {\n        this.pointerPosX = ev.touches[0].clientX\n        this.pointerPosY = ev.touches[0].clientY\n      }\n      // console.log('onTouchEnd', ev.touches.length)\n    },\n    onTouchMove (ev) {\n      if (ev.touches.length === 1) {\n        this.onPointerMove(ev.touches[0].clientX, ev.touches[0].clientY)\n      } else if (ev.touches.length === 2) {\n        // pos\n        let newMousePosX = (ev.touches[0].clientX + ev.touches[1].clientX) / 2\n        let newMousePosY = (ev.touches[0].clientY + ev.touches[1].clientY) / 2\n        this.onPointerMove(newMousePosX, newMousePosY)\n        this.pointerPosX = newMousePosX\n        this.pointerPosY = newMousePosY\n        // dist\n        let distX = ev.touches[0].clientX - ev.touches[1].clientX\n        let distY = ev.touches[0].clientY - ev.touches[1].clientY\n        let newTwoFingerDist = Math.sqrt(distX * distX + distY * distY)\n        this.tryToScale(newTwoFingerDist / this.twoFingerInitDist)\n        this.twoFingerInitDist = newTwoFingerDist\n      }\n      // console.log('onTouchMove', this.pointerPosX, this.pointerPosY)\n    },\n  },\n}\n</script>\n\n<style scoped>\n.vue-zoomer {\n  overflow: hidden;\n}\n.zoomer {\n  transform-origin: 50% 50%;\n  width: 100%;\n  height: 100%;\n}\n.zoomer > img {\n  /* remove the 4px gap below the image */\n  vertical-align: top;\n  user-drag: none;\n  -webkit-user-drag: none;\n  -moz-user-drag: none;\n}\n</style>\n"]},"metadata":{},"sourceType":"module"}